# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 1 3
# 10 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 11 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/newlib.h" 1 3
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 1 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 2 3
# 17 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3



# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 211 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 323 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 16 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3

# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 1 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 1 3
# 12 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 1 3






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 1 3
# 26 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 8 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 2 3
# 13 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3


typedef long _off_t;







typedef int __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 56 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 352 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 579 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 817 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 18 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 27 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;
# 58 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);
# 111 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) ;



void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);
# 198 "c:\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);



# 2 "main.c" 2
# 1 "myLib.h" 1



typedef unsigned short u16;
# 40 "myLib.h"
extern unsigned short *videoBuffer;

extern unsigned short *frontBuffer;
extern unsigned short *backBuffer;




void setPixel3(int row, int col, unsigned short color);
void drawRect3(int row, int col, int height, int width, unsigned short color);
void fillScreen3(unsigned short color);
void drawImage3(const unsigned short* image, int row, int col, int height, int width);


void setPixel4(int row, int col, unsigned char colorIndex);
void drawRect4(int row, int col, int height, int width, unsigned char colorIndex);
void fillScreen4(unsigned char color);

void drawBackgroundImage4(const unsigned short* image);
void drawImage4(const unsigned short* image, int row, int col, int height, int width);
void drawSubImage4(const unsigned short* sourceImage, int sourceRow, int sourceCol,
       int row, int col, int height, int width);

void loadPalette(const unsigned short* palette);
void initialize();

void waitForVblank();
void flipPage();




void splash();
void instructions();
void game();
void finish();
void pause();
void drawLevel();
void scrollVert();
void scorllHoriz();
void hideSprites();
void initializeSprites();
void initializeGame();
void updateOAM();
void updatePlayer();
void checkPlayerScreen();
void checkGravity();
void gravityLvl1();
void gravityLvl2();
void gravityLvl3();
void aliceMoveRight();
void aliceMoveLeft();
void aliceWalk();
void aliceJump();
void checkAliceCollision();
void aliceCollisionLvl1();
void aliceCollisionLvl2();
void aliceCollisionLvl3();
void aliceButterflies();
int checkButterflies();
void aliceIdle();
void checkItemCollide();
void checkForBottles();
void aliceDie();
void aliceRestart();
void finishLevel();
void playLevelMusic();
void cheatMode();
void delay();
# 129 "myLib.h"
extern unsigned int oldButtons;
extern unsigned int buttons;
# 139 "myLib.h"
void DMANow(int channel, volatile const void* source, volatile void* destination, unsigned int control);






typedef volatile struct
{
        volatile const void *src;
        volatile void *dst;
        volatile unsigned int cnt;
} DMA;

extern DMA *dma;
# 265 "myLib.h"
typedef struct { u16 tileimg[8192]; } charblock;
typedef struct { u16 tilemap[1024]; } screenblock;
# 326 "myLib.h"
typedef struct{
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
}OBJ_ATTR;
# 3 "main.c" 2
# 1 "text.h" 1
# 10 "text.h"
void drawChar3(int row, int col, char ch, volatile unsigned short color);
void drawString3(int row, int col, char *str,volatile unsigned short color);


void drawChar4(int row, int col, char ch,volatile unsigned char colorIndex);
void drawString4(int row, int col, char *str,volatile unsigned char colorIndex);

extern const unsigned char fontdata_6x8[12288];
# 4 "main.c" 2
# 1 "bg0.h" 1
# 22 "bg0.h"
extern const unsigned short bg0Tiles[1792];


extern const unsigned short bg0Map[1024];


extern const unsigned short bg0Pal[256];
extern const unsigned short bg0Pal_2[256];
# 5 "main.c" 2
# 1 "bg0_alt.h" 1
# 22 "bg0_alt.h"
extern const unsigned short bg0_altTiles[1952];


extern const unsigned short bg0_altMap[1024];


extern const unsigned short bg0_altPal[256];
# 6 "main.c" 2
# 1 "bg1.h" 1
# 22 "bg1.h"
extern const unsigned short bg1Tiles[6592];


extern const unsigned short bg1Map[1024];


extern const unsigned short bg1Pal[256];
# 7 "main.c" 2
# 1 "lvl1.h" 1
# 22 "lvl1.h"
extern const unsigned short lvl1Tiles[4480];


extern const unsigned short lvl1Map[4096];


extern const unsigned short lvl1Pal[256];
# 8 "main.c" 2
# 1 "lvl2.h" 1
# 22 "lvl2.h"
extern const unsigned short lvl2Tiles[5632];


extern const unsigned short lvl2Map[4096];


extern const unsigned short lvl2Pal[256];
# 9 "main.c" 2
# 1 "lvl3.h" 1
# 22 "lvl3.h"
extern const unsigned short lvl3Tiles[9280];


extern const unsigned short lvl3Map[4096];


extern const unsigned short lvl3Pal[256];
# 10 "main.c" 2
# 1 "collisionMap_1.h" 1
# 20 "collisionMap_1.h"
extern const unsigned short collisionMap_1Bitmap[262144];
# 11 "main.c" 2
# 1 "collisionMap_2.h" 1
# 20 "collisionMap_2.h"
extern const unsigned short collisionMap_2Bitmap[262144];
# 12 "main.c" 2
# 1 "collisionMap_3.h" 1
# 20 "collisionMap_3.h"
extern const unsigned short collisionMap_3Bitmap[262144];
# 13 "main.c" 2
# 1 "sound.h" 1
typedef struct{
    const unsigned char* data;
    int length;
    int frequency;
    int isPlaying;
    int loops;
    int duration;
    int priority;
}SOUND;

SOUND soundA;
SOUND soundB;
int vbCountA;
int vbCountB;

void setupSounds();
void playSoundA( const unsigned char* sound, int length, int frequency);
void playSoundB( const unsigned char* sound, int length, int frequency);
void muteSound();
void unmuteSound();
void stopSound();
void pauseSound();
void unpauseSound();

void setupInterrupts();
void interruptHandler();
# 14 "main.c" 2
# 1 "splash.h" 1
# 21 "splash.h"
extern const unsigned short splashBitmap[19200];


extern const unsigned short splashPal[256];
# 15 "main.c" 2
# 1 "instructions.h" 1
# 21 "instructions.h"
extern const unsigned short instructionsBitmap[19200];


extern const unsigned short instructionsPal[256];
# 16 "main.c" 2
# 1 "pausescreen.h" 1
# 21 "pausescreen.h"
extern const unsigned short pausescreenBitmap[19200];


extern const unsigned short pausescreenPal[256];
# 17 "main.c" 2
# 1 "finishscreen.h" 1
# 21 "finishscreen.h"
extern const unsigned short finishscreenBitmap[19200];


extern const unsigned short finishscreenPal[256];
# 18 "main.c" 2
# 1 "splashSong.h" 1
# 20 "splashSong.h"
extern const unsigned char splashSong[4556160];
# 19 "main.c" 2
# 1 "gameSong.h" 1
# 20 "gameSong.h"
extern const unsigned char gameSong[3037440];
# 20 "main.c" 2
# 1 "gameSong_2.h" 1
# 20 "gameSong_2.h"
extern const unsigned char gameSong_2[4730496];
# 21 "main.c" 2
# 1 "select.h" 1
# 20 "select.h"
extern const unsigned char select[15132];
# 22 "main.c" 2
# 1 "jump.h" 1
# 20 "jump.h"
extern const unsigned char jump[1733];
# 23 "main.c" 2
# 1 "cheat.h" 1
# 20 "cheat.h"
extern const unsigned char cheat[42624];
# 24 "main.c" 2
# 1 "pickup.h" 1
# 20 "pickup.h"
extern const unsigned char pickup[4207];
# 25 "main.c" 2
# 1 "whoosh.h" 1
# 20 "whoosh.h"
extern const unsigned char whoosh[23040];
# 26 "main.c" 2
# 1 "finishSong.h" 1
# 20 "finishSong.h"
extern const unsigned char finishSong[1431841];
# 27 "main.c" 2
# 1 "endlevel.h" 1
# 20 "endlevel.h"
extern const unsigned char endlevel[66152];
# 28 "main.c" 2
# 1 "flutter.h" 1
# 20 "flutter.h"
extern const unsigned char flutter[24948];
# 29 "main.c" 2
# 1 "Alice.h" 1
# 22 "Alice.h"
extern const unsigned short AliceTiles[16384];


extern const unsigned short AliceMap[1024];


extern const unsigned short AlicePal[256];
# 30 "main.c" 2
# 62 "main.c"
unsigned int buttons;
unsigned int oldButtons;

int hOff=0;
int hOff2 = 0;
int vOff = 95;
int heightofScreen = 256;
int bottlesTotal;
int gravity = 1;
int state;
int level;

int lev1col[] = {70, 215, 360, 0, 0};
int lev1row[] = {175, 175, 60, 0, 0};
int lev2col[] = {81, 182, 370, 0, 0};
int lev2row[] = {73, 173, 190, 0, 0};
int lev3col[] = {98, 238, 320, 92, 237};
int lev3row[] = {420, 420, 250, 50, 50};

OBJ_ATTR shadowOAM[128];


typedef struct
{
 int row;
 int col;
 int bigRow;
 int bigCol;
 int rdel;
    int cdel;
    int racc;
    int cacc;
 int width;
    int height;
    int aniCounter;
    int aniState;
    int prevAniState;
    int currFrame;
    int maxC;
    int maxR;
    int butterflies;
    int isGrounded;
    int isFalling;
    int isGliding;
    int isDead;
    int isJumping;
    int blueSmoke;
    int redSmoke;
    int isCheating;
} PLAYER;

typedef struct
{
 int row;
 int col;
 int bigRow;
 int bigCol;
 int width;
    int height;
    int isActive;
    int isOnScreen;
} BOTTLE;

PLAYER alice;
PLAYER* aliceptr = &alice;

BOTTLE bottles[5];

enum {LEV1,LEV2,LEV3};

enum {ALICERUNRIGHT=0, ALICERUNLEFT=2, ALICEIDLERIGHT=4, ALICEIDLELEFT=6, ALICEAIRRIGHT=8, ALICEAIRLEFT=10, ALICEBUTTERFLYRIGHT=12,ALICEBUTTERFLYLEFT=14};


int main()
{

    initialize();
    setupInterrupts();
    setupSounds();

    state = 0;

 while(1)
 {
  oldButtons = buttons;
        buttons = *(volatile unsigned int *)0x04000130;

        level = 0;
        vOff = 95;
        initializeSprites();

   switch(state)
  {
   case 0:
    splash();
    state = 1;
    break;

   case 1:
    instructions();
    stopSound();
    playSoundB(select,15132,44100);
    hideSprites();
       initializeSprites();
    initializeGame();
    stopSound();
    state = 2;
    break;
   case 2:
    game();
    initialize();
    break;
   case 3:
    stopSound();
    finish();
    stopSound();
    state = 0;
    break;
   case 4:
    playSoundB(select,15132,44100);
    pauseSound();
    pause();
    break;
  }
 }

 return 0;
}

void initialize() {

 *(unsigned short *)0x4000000 = 4 | (1<<10);

 ((u16 *)0x5000000)[1] = ((31) | (0)<<5 | (0)<<10);
 ((u16 *)0x5000000)[2] = ((0) | (31)<<5 | (0)<<10);
 ((u16 *)0x5000000)[3] = ((0) | (0)<<5 | (31)<<10);
 ((u16 *)0x5000000)[4] = ((31) | (31)<<5 | (31)<<10);
 ((u16 *)0x5000000)[5] = ((0) | (0)<<5 | (0)<<10);
}

void initializeGame() {
 *(unsigned short *)0x4000000 = 0 | (1<<8) | (1<<9) | (1<<10) | (1 << 12);

 *(volatile unsigned short*)0x4000008 = 0<<14 | 0 << 2 | 2 << 8 | 1 << 7 | 2;
 *(volatile unsigned short*)0x400000A = 0<<14 | 1 << 2 | 15 << 8 | 1 << 7 | 1;
 *(volatile unsigned short*)0x400000C = 3<<14 | 2 << 2 | 25 << 8 | 1 << 7;

 drawLevel();

    DMANow(3,AlicePal,((unsigned short*)(0x5000200)),512/2);
    DMANow(3,AliceTiles,&((charblock *)0x6000000)[4],32768/2);

}


void splash() {
 playSoundA(splashSong,4556160,44100);
 loadPalette(splashPal);
 drawBackgroundImage4(splashBitmap);
 while(!(~(*(volatile unsigned int *)0x04000130) & ((1<<3)))) {
    }

    while ((~(*(volatile unsigned int *)0x04000130) & ((1<<3)))) {
    }

}

void instructions() {
 loadPalette(instructionsPal);
 drawBackgroundImage4(instructionsBitmap);

    while(!(~(*(volatile unsigned int *)0x04000130) & ((1<<3)))){
    }

    while ((~(*(volatile unsigned int *)0x04000130) & ((1<<3)))) {

    }
}

void game() {

 playLevelMusic();
 while(1 && state == 2) {

  oldButtons = buttons;
     buttons = *(volatile unsigned int *)0x04000130;

     updatePlayer();
     checkPlayerScreen();
     checkItemCollide();
     scrollVert();
     scorllHoriz();
     checkAliceCollision();
     checkForBottles();

     alice.bigRow = alice.row + vOff;
  alice.bigCol = alice.col + hOff/2;

  checkGravity();

  updateOAM();

  *(volatile unsigned short *)0x04000010 = hOff2/30;
  *(volatile unsigned short *)0x04000014 = hOff2/25;
  *(volatile unsigned short *)0x04000018 = hOff/2;
  *(volatile unsigned short *)0x0400001A = vOff;

  for (int i = 0; i < 5; i++) {
   if (bottles[i].col >= 0 && bottles[i].row >= 0 && bottles[i].col <= 240 && bottles[i].row <= 160) {
    bottles[i].isOnScreen = 1;
   } else {
    bottles[i].isOnScreen = 0;
   }
  }

  if (hOff <= 0) hOff = 1;
  else if (hOff >= 540) hOff = 540;
  else {
   for (int i = 0; i < 5; i++) {
    bottles[i].col = bottles[i].bigCol - hOff/2;
    bottles[i].row = bottles[i].bigRow - vOff;
   }
  }


  if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
   state = 4;
   return;
  }



  waitForVblank();
 }

 return;
}

void finish() {
 playSoundA(finishSong,1431841,44100);
 loadPalette(finishscreenPal);
 drawBackgroundImage4(finishscreenBitmap);

    while(!(~(*(volatile unsigned int *)0x04000130) & ((1<<3)))){
    }

    while ((~(*(volatile unsigned int *)0x04000130) & ((1<<3)))) {

    }
}

void pause() {
 loadPalette(pausescreenPal);
 drawBackgroundImage4(pausescreenBitmap);
    while (1) {
     oldButtons = buttons;
        buttons = *(volatile unsigned int *)0x04000130;

     if ((!(~(oldButtons)&((1<<3))) && (~buttons & ((1<<3))))) {
      state = 2;
      unpauseSound();
      initializeGame();
      return;
     }

     if ((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
      state = 0;
      stopSound();
      return;
     }
    }
}

void drawLevel() {
 switch (level) {
  case LEV1:
   loadPalette(bg0Pal);
   DMANow(3,bg0Tiles, &((charblock *)0x6000000)[0], 3584/2);
   DMANow(3,bg0Map,&((screenblock *)0x6000000)[2],2048/2);
   DMANow(3,bg1Tiles, &((charblock *)0x6000000)[1], 13184/2);
   DMANow(3,bg1Map,&((screenblock *)0x6000000)[15],2048/2);
      DMANow(3,lvl1Tiles, &((charblock *)0x6000000)[2],8960/2);
      DMANow(3,lvl1Map,&((screenblock *)0x6000000)[25],8192/2);
      *(volatile unsigned short *)0x0400001A = vOff;
      break;
  case LEV2:
   loadPalette(bg0Pal_2);
   DMANow(3,bg0Tiles, &((charblock *)0x6000000)[0], 3584/2);
      DMANow(3,bg0Map,&((screenblock *)0x6000000)[2],2048/2);
    DMANow(3,bg1Tiles, &((charblock *)0x6000000)[1], 13184/2);
      DMANow(3,bg1Map,&((screenblock *)0x6000000)[15],2048/2);
      DMANow(3,lvl2Tiles, &((charblock *)0x6000000)[2],11264/2);
      DMANow(3,lvl2Map,&((screenblock *)0x6000000)[25],8192/2);
      *(volatile unsigned short *)0x0400001A = vOff;
   break;
  case LEV3:
   loadPalette(bg0_altPal);
   DMANow(3,bg0_altTiles, &((charblock *)0x6000000)[0], 3904/2);
      DMANow(3,bg0_altMap,&((screenblock *)0x6000000)[2],2048/2);
    DMANow(3,bg1Tiles, &((charblock *)0x6000000)[1], 13184/2);
      DMANow(3,bg1Map,&((screenblock *)0x6000000)[15],2048/2);
      DMANow(3,lvl3Tiles, &((charblock *)0x6000000)[2],18560/2);
      DMANow(3,lvl3Map,&((screenblock *)0x6000000)[25],8192/2);
      vOff = 186;
      *(volatile unsigned short *)0x0400001A = vOff;
   break;
 }
}

void hideSprites() {
    int i;
    for (i = 0; i < 128; i++) {
     shadowOAM[i].attr0 = (2 << 8);
    }
}

void initializeSprites() {
 alice.width = 32;
    alice.height = 64;
    alice.rdel = 0;
    alice.cdel = 0;
    if (level == 2) alice.row = 40;
    else alice.row = 20;
 alice.col = 10;
 alice.racc = 3;
 alice.cacc = 1;
 alice.maxC = 10;
 alice.maxR = 5;
 alice.isGrounded = 0;
 alice.isFalling = 0;
 alice.isGliding = 0;
 alice.isJumping = 0;
 alice.blueSmoke = 0;
 alice.redSmoke = 0;
 alice.isCheating = 0;

 alice.aniCounter = 0;
    alice.currFrame = 0;

    for(int i = 0; i < 5; i++)
 {
  bottles[i].width = 32;
  bottles[i].height = 32;
  if (level == 0) {
   bottles[i].bigRow = lev1row[i];
   bottles[i].bigCol = lev1col[i];
  } else if (level == 1) {
   bottles[i].bigRow = lev2row[i];
   bottles[i].bigCol = lev2col[i];
  } else if (level == 2) {
   bottles[i].bigRow = lev3row[i];
   bottles[i].bigCol = lev3col[i];
  }
  if (bottles[i].bigRow != 0 && bottles[i].bigCol != 0) bottles[i].isActive = 1;
  else bottles[i].isActive = 0;
  bottles[i].row = bottles[i].bigRow - vOff;
  bottles[i].col = bottles[i].bigCol - hOff/2;
 }
     buttons = *(volatile unsigned int *)0x04000130;
}

void updateOAM() {


    if (aliceptr->isDead) {
        shadowOAM[0].attr0 = (alice.row & 0xFF) | (0 << 14) | (0 << 13);
  shadowOAM[0].attr1 = ((alice.col-16) & 0x1FF) | (3 << 14);
  shadowOAM[0].attr2 = ((2*alice.currFrame)*32+(2*alice.aniState)) | ((aliceptr->isCheating<<12));
 } else if (!aliceptr->isDead && !aliceptr->blueSmoke && !aliceptr->redSmoke) {
  shadowOAM[0].attr0 = (alice.row & 0xFF) | (2 << 14) | (0 << 13);
  shadowOAM[0].attr1 = (alice.col & 0x1FF) | (3 << 14);
  shadowOAM[0].attr2 = ((2*alice.currFrame)*32+(2*alice.aniState)) | ((aliceptr->isCheating<<12));
 } else if (!aliceptr->isDead && aliceptr->blueSmoke) {
  shadowOAM[0].attr0 = (alice.row & 0xFF) | (0 << 14) | (0 << 13);
  shadowOAM[0].attr1 = ((alice.col-16) & 0x1FF) | (3 << 14);
  shadowOAM[0].attr2 = (2*8)*32+(2*12);
 } else if (!aliceptr->isDead && aliceptr->redSmoke) {
  shadowOAM[0].attr0 = (alice.row & 0xFF) | (0 << 14) | (0 << 13);
  shadowOAM[0].attr1 = ((alice.col-16) & 0x1FF) | (3 << 14);
  shadowOAM[0].attr2 = ((2*12)*32+(2*12)) | ((aliceptr->isCheating<<12));
 }


 for (int i = 0; i < 5; i++) {
  if (bottles[i].isActive && bottles[i].isOnScreen) {
   shadowOAM[i+1].attr0 = (bottles[i].row & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[i+1].attr1 = (bottles[i].col & 0x1FF) | (2 << 14);
   shadowOAM[i+1].attr2 = (2*4)*32+(2*4);
  } else {
   shadowOAM[i+1].attr0 = (2 << 8);
  }
 }




  shadowOAM[7].attr0 = ((0) & 0xFF) | (1 << 14) | (0 << 13);
  shadowOAM[7].attr1 = ((0) & 0x1FF) | (3 << 14);
  shadowOAM[7].attr2 = (2*6)*32+(2*4);


  if(bottlesTotal == 0) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*8)*32+(2*4);
  } else if (bottlesTotal == 1) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*8)*32+(2*6);
  } else if (bottlesTotal == 2) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*10)*32+(2*4);
  } else if (bottlesTotal == 3) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*10)*32+(2*6);
  } else if (bottlesTotal == 4) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*12)*32+(2*4);
  } else if (bottlesTotal == 5) {
   shadowOAM[8].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[8].attr1 = ((53) & 0x1FF) | (2 << 14);
   shadowOAM[8].attr2 = (2*12)*32+(2*6);
  }


  shadowOAM[9].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
  shadowOAM[9].attr1 = ((66) & 0x1FF) | (2 << 14);
  shadowOAM[9].attr2 = (2*14)*32+(2*4);


  if (level < 2) {
   shadowOAM[10].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[10].attr1 = ((75) & 0x1FF) | (2 << 14);
   shadowOAM[10].attr2 = (2*10)*32+(2*6);
  } else if (level == 2) {
   shadowOAM[10].attr0 = ((0) & 0xFF) | (0 << 14) | (0 << 13);
   shadowOAM[10].attr1 = ((75) & 0x1FF) | (2 << 14);
   shadowOAM[10].attr2 = (2*12)*32+(2*6);
  }

    DMANow(3,shadowOAM,((OBJ_ATTR*)(0x7000000)),512);
}


void updatePlayer() {

 if (aliceptr->aniState == 0 || aliceptr->aniState == 2)
 {
  aliceptr->prevAniState = aliceptr->aniState;
 }

 aliceIdle();

 if ((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0)))))
    {
     aliceJump();
    }

    if ((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1)))))
    {
     aliceButterflies();
    }

    if ((!(~(oldButtons)&((1<<2))) && (~buttons & ((1<<2))))) {
     cheatMode();
    }

    if (checkButterflies() && aliceptr->cdel == 0 && (aliceptr->isGliding || aliceptr->isCheating)) {
     if (aliceptr->aniState == ALICEBUTTERFLYRIGHT) {
    aliceptr->aniState = ALICEAIRRIGHT;
   } else if (aliceptr->aniState == ALICEBUTTERFLYLEFT) {
    aliceptr->aniState = ALICEAIRLEFT;
  }
    }

    aliceWalk();
}

void scrollVert() {
 if (level < 2) {
     if (vOff <= 1 && alice.row < 50)
     {
         alice.row+=alice.rdel/4;
     } else if (vOff >= 95 && alice.row + 64 > 50) {
      alice.row+=alice.rdel/4;
     } else if (vOff <= 1 && alice.row > 50) {
      alice.row+=alice.rdel/4;
     } else {
      vOff+=alice.rdel/4;
     }
 } else if (level == 2) {
  if (vOff <= 7 && alice.row < 50)
     {
         alice.row+=alice.rdel/4;
     } else if (vOff >= 352 && alice.isFalling) {
      alice.row+=alice.rdel/4;
     } else if (vOff >= 352 && alice.row + 64 > 160) {
      alice.row+=alice.rdel/4;
     } else if (vOff <= 7 && alice.row > 50) {
      alice.row+=alice.rdel/4;
     } else {
      vOff+=alice.rdel/4;
     }
 }
}

void scorllHoriz() {
 if ((~(*(volatile unsigned int *)0x04000130) & ((1<<4))) || checkButterflies()) {
            if ((hOff > 538 || hOff < 2) && alice.col < 100)
            {
                alice.col += alice.cdel/4;
            } else if (hOff > 538 && alice.col + 42 > 100) {
             alice.col += alice.cdel/4;
            } else {
          hOff+=alice.cdel/3;
          hOff2++;
            }
        }


        if ((~(*(volatile unsigned int *)0x04000130) & ((1<<5))) || checkButterflies()) {
            if ((hOff > 538 || hOff < 2) && alice.col >= 100)
            {
                alice.col += alice.cdel/4;
            } else if (hOff < 2 && alice.col - 10 < 100) {
             alice.col += alice.cdel/4;
            } else {
          hOff+=alice.cdel/3;
          hOff2--;
            }
        }

}


void checkPlayerScreen() {
  if (aliceptr->row == 256) aliceptr->row = 0;
  if (aliceptr->rdel < 0 && aliceptr->row <= 0) aliceptr->row = 0;

  if (aliceptr->isGliding && aliceptr->row <= 512 && aliceptr->row >= 160 && level < 2) {
   if (vOff >= 0) {
    vOff-=7;
   }
  }

  if (aliceptr->isGliding && aliceptr->row >= 160 && level == 2) {
   if (vOff > 7) {
    vOff-=7;
   }
  }

  if (aliceptr->row == 160) {
   if (level == 2) aliceptr->row = 170;
   aliceptr->isGliding = 1;
   if (aliceptr->prevAniState == ALICERUNRIGHT) {
    aliceptr->aniState = ALICEAIRRIGHT;
   } else if (aliceptr->prevAniState == ALICERUNLEFT) {
    aliceptr->aniState = ALICEAIRLEFT;
   }
      aliceptr->currFrame = 0;
  }


  if (aliceptr->col < 0)
  {
      aliceptr->col = 0;
      aliceptr->cdel = 0;
  }

  if(aliceptr->col >= (240-aliceptr->width)) {
      aliceptr->col = (239-aliceptr->width);
      aliceptr->cdel = 0;
  }
}

void aliceMoveLeft() {
 aliceptr->aniCounter++;
 if (aliceptr->cdel >= -(aliceptr->maxC))
    {
        aliceptr->cdel -= aliceptr->cacc;
    }

    if (aliceptr->isGrounded && aliceptr->isFalling == 0) {
  aliceptr->aniState = ALICERUNLEFT;

  if(aliceptr->aniCounter%12==0)
  {
   if (aliceptr->currFrame == 12) {
    aliceptr->currFrame = 4;
   }
   else {
    aliceptr->currFrame+=4;
   }
  }
 } else if (aliceptr->isGrounded == 0 && aliceptr->isFalling && aliceptr->isGliding) {
  aliceptr->aniState = ALICEAIRLEFT;
  aliceptr->currFrame = 0;

 }
}

void aliceMoveRight() {
 aliceptr->aniCounter++;
 if (aliceptr->cdel <= aliceptr->maxC)
 {
  aliceptr->cdel += aliceptr->cacc;
 }
    if (aliceptr->isGrounded && aliceptr->isFalling == 0)
    {
     aliceptr->aniState = ALICERUNRIGHT;

        if(aliceptr->aniCounter%12==0)
  {
   if (aliceptr->currFrame == 12) {
    aliceptr->currFrame = 4;
   }
   else {
    aliceptr->currFrame+=4;
   }
  }
 } else if (aliceptr->isGrounded == 0 && aliceptr->isFalling && aliceptr->isGliding) {
  aliceptr->aniState = ALICEAIRRIGHT;
  aliceptr->currFrame = 0;

 }
}

void aliceWalk() {
 if ((~(*(volatile unsigned int *)0x04000130) & ((1<<5))) && !checkButterflies())
    {
     aliceMoveLeft();
 }

    else if ((~(*(volatile unsigned int *)0x04000130) & ((1<<4))) && !checkButterflies())
    {
     aliceMoveRight();
    }

    else
    {
        if (aliceptr->cdel > 0)
        {
            aliceptr->cdel--;
        }
        else if (aliceptr->cdel < 0)
        {
            aliceptr->cdel++;
        }
        else if (aliceptr->cdel == 0) {
         aliceptr->cdel = 0;
        }
    }
}

void checkGravity() {
 if (level == 0) {
  gravityLvl1();
 }

 if (level == 1) {
  gravityLvl2();
 }

 if (level == 2) {
  gravityLvl3();
 }
}

void gravityLvl1() {
 if (collisionMap_1Bitmap[((aliceptr->bigRow + aliceptr->height-2)*(512)+(aliceptr->bigCol+16))] == ((31) | (31)<<5 | (31)<<10)) {
        if (aliceptr->rdel <= aliceptr->maxR) {
         aliceptr->rdel += gravity;
         aliceptr->isGrounded = 0;
        }

        if (aliceptr->rdel >= 2) {
   aliceptr->isFalling = 1;
  }
    } else if (collisionMap_1Bitmap[((aliceptr->bigRow + aliceptr->height-2)*(512)+(aliceptr->bigCol+16))] == ((0) | (0)<<5 | (0)<<10)) {
     if (aliceptr->row >= 0 && aliceptr->row + 64 <= 160) {
   aliceptr->isFalling = 0;
   if (aliceptr->isGrounded == 0) {
    aliceptr->isJumping = 0;
    aliceptr->rdel = 0;
    aliceptr->isGrounded = 1;
    aliceptr->isGliding = 0;
   }
  }
 }
}

void gravityLvl2() {
 if (collisionMap_2Bitmap[((aliceptr->bigRow + aliceptr->height-1)*(512)+(aliceptr->bigCol+16))] == ((31) | (31)<<5 | (31)<<10)) {
        if (aliceptr->rdel <= aliceptr->maxR) {
         aliceptr->rdel += gravity;
         aliceptr->isGrounded = 0;
        }

        if (aliceptr->rdel >= 2) {
   aliceptr->isFalling = 1;
  }
    } else if (collisionMap_2Bitmap[((aliceptr->bigRow + aliceptr->height-1)*(512)+(aliceptr->bigCol+16))] == ((0) | (0)<<5 | (0)<<10)) {
     if (aliceptr->row >= 0 && aliceptr->row + 64 <= 160) {
   aliceptr->isFalling = 0;
   if (aliceptr->isGrounded == 0) {
    aliceptr->isJumping = 0;
    aliceptr->rdel = 0;
    aliceptr->isGrounded = 1;
    aliceptr->isGliding = 0;
   }
  }
 } else if (collisionMap_2Bitmap[((aliceptr->bigRow + aliceptr->height-1)*(512)+(aliceptr->bigCol+16))] == ((31) | (0)<<5 | (0)<<10)) {
  if (aliceptr->row >= 0 && aliceptr->row + 64 <= 160 && !aliceptr->isCheating) {
   aliceptr->rdel = 0;
   aliceptr->isDead = 1;
   aliceDie();
  }
 }
}

void gravityLvl3() {
 if (collisionMap_3Bitmap[((aliceptr->bigRow + aliceptr->height-2)*(512)+(aliceptr->bigCol+16))] == ((31) | (31)<<5 | (31)<<10)) {
        if (aliceptr->rdel <= aliceptr->maxR) {
         aliceptr->rdel += gravity;
         aliceptr->isGrounded = 0;
        }

        if (aliceptr->rdel >= 2) {
   aliceptr->isFalling = 1;
  }
    } else if (collisionMap_3Bitmap[((aliceptr->bigRow + aliceptr->height-2)*(512)+(aliceptr->bigCol+16))] == ((0) | (0)<<5 | (0)<<10)) {
  if (aliceptr->row >= 0 && aliceptr->row + 64 <= 160) {
   aliceptr->isFalling = 0;
   if (aliceptr->isGrounded == 0) {
    aliceptr->isJumping = 0;
    aliceptr->rdel = 0;
    aliceptr->isGrounded = 1;
    aliceptr->isGliding = 0;
   }
  }
 } else if (collisionMap_3Bitmap[((aliceptr->bigRow + aliceptr->height-2)*(512)+(aliceptr->bigCol+16))] == ((31) | (0)<<5 | (0)<<10)) {
  if (aliceptr->row >= 0 && aliceptr->row + 64 <= 160 && !aliceptr->isCheating) {
   aliceptr->rdel = 0;
   aliceptr->isDead = 1;
   aliceDie();
  }

 }
}

void checkAliceCollision() {
 if (aliceptr->isFalling && !aliceptr->isGliding) {

  if (level == 0) {
   aliceCollisionLvl1();
  }

  if (level == 1) {
   aliceCollisionLvl2();
  }

  if (level == 2) {
   aliceCollisionLvl3();
  }
 }
}

void aliceCollisionLvl1() {
 if (collisionMap_1Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 16))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->row--;
  aliceptr->col++;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_1Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
}

void aliceCollisionLvl2() {
 if (collisionMap_2Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 16))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->row--;
  aliceptr->col++;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_2Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
}

void aliceCollisionLvl3() {
 if (collisionMap_3Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col++;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 16))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->row--;
  aliceptr->col++;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow + 32 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
 else if (collisionMap_3Bitmap[((aliceptr->bigRow + 64 - 1)*(512)+(aliceptr->bigCol + 32))] == 0x0000)
 {
  aliceptr->cdel = 0;
  aliceptr->col--;
 }
}


void aliceJump() {
 if (aliceptr->isGrounded && aliceptr->isFalling == 0) {
  playSoundB(jump,1733,11025);
  aliceptr->isJumping = 1;
  aliceptr->rdel = -15;
 }
}

int checkButterflies() {
 if ((aliceptr->aniState == 12 || aliceptr->aniState == 14)) {
  gravity = 0;
  aliceptr->rdel = 0;
  return 1;
 }
 gravity = 1;
 return 0;
}

void aliceButterflies() {
 if((aliceptr->isCheating || aliceptr->isGliding) && aliceptr->rdel != 0) {
  playSoundB(flutter,24948,44100);
  if (aliceptr->aniState == ALICEAIRRIGHT || aliceptr->aniState == ALICERUNRIGHT || aliceptr->aniState == ALICEIDLERIGHT) {
      aliceptr->aniState = ALICEBUTTERFLYRIGHT;
      aliceptr->currFrame = 0;
   aliceptr->cdel = 28;
  } else if (aliceptr->aniState == ALICEAIRLEFT || aliceptr->aniState == ALICERUNLEFT || aliceptr->aniState == ALICEIDLELEFT) {
   aliceptr->aniState = ALICEBUTTERFLYLEFT;
   aliceptr->cdel = -28;
   aliceptr->currFrame = 0;
  }
 }
}

void aliceIdle() {
 if (aliceptr->cdel == 0 && aliceptr->isFalling == 0 && aliceptr->isGrounded && !aliceptr->isDead) {
  if (aliceptr->prevAniState == ALICERUNRIGHT && !(~(*(volatile unsigned int *)0x04000130) & ((1<<4)))) {
   aliceptr->aniState = ALICEIDLERIGHT;
   aliceptr->currFrame = 0;
  } else if (aliceptr->prevAniState == ALICERUNLEFT && !(~(*(volatile unsigned int *)0x04000130) & ((1<<5)))) {
   aliceptr->aniState = ALICEIDLELEFT;
   aliceptr->currFrame = 0;
  }
 }
}

void checkItemCollide() {
 for (int i = 0; i < 5; i++) {

  if (aliceptr->row - 5 > bottles[i].row && aliceptr->row - 5 < bottles[i].row + 32 && aliceptr->col - 5 < bottles[i].col + 32 && aliceptr->col - 5 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row + 64 + 5 > bottles[i].row && aliceptr->row + 64 + 5 < bottles[i].row + 32 && aliceptr->col + 32 + 5 < bottles[i].col + 32 && aliceptr->col + 32 + 5 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row + 32 > bottles[i].row && aliceptr->row + 32 < bottles[i].row + 32 && aliceptr->col + 5 < bottles[i].col + 32 && aliceptr->col + 5 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row - 5 > bottles[i].row && aliceptr->row - 5 < bottles[i].row + 32 && aliceptr->col + 16< bottles[i].col + 32 && aliceptr->col + 16 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row - 5 > bottles[i].row && aliceptr->row - 5 < bottles[i].row + 32 && aliceptr->col + 32 + 5 < bottles[i].col + 32 && aliceptr->col + 32 + 5> bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row + 64 + 5 > bottles[i].row && aliceptr->row + 64 + 5 < bottles[i].row + 32 && aliceptr->col + 16 < bottles[i].col + 32 && aliceptr->col + 16 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row + 32 > bottles[i].row && aliceptr->row + 32 < bottles[i].row + 32 && aliceptr->col - 5 < bottles[i].col + 32 && aliceptr->col - 5 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }

  else if (aliceptr->row + 64 + 5 > bottles[i].row && aliceptr->row + 64 + 5 < bottles[i].row + 32 && aliceptr->col - 5 < bottles[i].col + 32 && aliceptr->col - 5 > bottles[i].col) {
   if(bottles[i].isActive) playSoundB(pickup,4207,11025);
   bottles[i].isActive = 0;
  }
 }
}

void aliceDie() {
 stopSound();
 playSoundB(whoosh,23040,24000);
 aliceptr->rdel = 0;
 aliceptr->cdel = 0;
 aliceptr->currFrame = 4;
 aliceptr->aniState = 8;
 updateOAM();
 delay();
 aliceptr->currFrame = 4;
 aliceptr->aniState = 12;
 updateOAM();
 delay();
 delay();
 aliceRestart();
}

void aliceRestart() {
 delay();
 aliceptr->isDead = 0;
 hideSprites();
 if (level < 2) {
  while (vOff < 95) vOff += 2;
 } else {
  vOff = 180;
 }
 while (hOff > 0) hOff -= 2;
 aliceptr->currFrame = 0;
 aliceptr->aniState = ALICEIDLERIGHT;
 initializeSprites();
 playLevelMusic();
}

void checkForBottles() {
 int total = 0;
 for (int i = 0; i < 5; i++ ) {
  if (!bottles[i].isActive) total++;
 }
 if (level == 2) bottlesTotal = total;
 else bottlesTotal = (total - 2);

 if (total == 5 && (aliceptr->bigCol + 100) >= 538 && aliceptr->rdel == 0 && aliceptr->cdel == 0) finishLevel();

}

void finishLevel() {
 stopSound();
 playSoundB(endlevel,66152,44100);
 if (aliceptr->isCheating) aliceptr->redSmoke = 1;
 else aliceptr->blueSmoke = 1;
 updateOAM();
 delay();
 delay();
 level++;
 if (level == 2) heightofScreen = 512;
 hOff = 0;
 initializeGame();
 hideSprites();
 initializeSprites();
 playLevelMusic();

 if (level == 3) {
  state = 3;
 }

}

void playLevelMusic() {
 if (aliceptr->isCheating) {
     if (level == 0) playSoundA(gameSong,3037440,20000);
     else if (level == 1) playSoundA(gameSong_2,4730496,20000);
     else if (level == 2) playSoundA(gameSong_2,4730496,44100/4);
 } else {
  if (level == 0) playSoundA(gameSong,3037440,44000);
     else if (level == 1) playSoundA(gameSong_2,4730496,44000);
     else if (level == 2) playSoundA(gameSong_2,4730496,44100/3);
 }
}

void cheatMode() {
 stopSound();
 playSoundB(cheat,42624,44100);
 aliceptr->isCheating = 1;
 aliceptr->redSmoke = 1;
 updateOAM();
 delay();
 delay();
 aliceptr->redSmoke = 0;
 playLevelMusic();
}

void delay() {
  int i;
  volatile int b;
  for(i=0;i<200000;i++) {
     b++;
  }
}
